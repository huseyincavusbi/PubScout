# interactive_scout.py
# A Slack bot that provides an interactive interface to the PubScout knowledge base.
# Allows users to ask questions and get synthesized answers from the vector DB.

import os
import logging
import config
from dotenv import load_dotenv
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler

# --- RAG/AI IMPORTS ---
import chromadb
from sentence_transformers import SentenceTransformer
from groq import Groq

# --- CONFIGURATION & CLIENT INITIALIZATION ---
load_dotenv()
# For slack_bolt, you need both a Bot Token (for posting messages) and an App Token (for Socket Mode)
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_APP_TOKEN = os.getenv("SLACK_APP_TOKEN") # You will create this in the Slack API settings
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

# --- LOGGING SETUP ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- INITIALIZE CLIENTS & MODELS ---
try:
    # Initialize the Slack App using Socket Mode for easy local development
    app = App(token=SLACK_BOT_TOKEN)
    groq_client = Groq(api_key=GROQ_API_KEY)
    
    # Connect to the existing vector database
    chroma_client = chromadb.PersistentClient(path=config.VECTOR_DB_PATH)
    embedding_model = SentenceTransformer(config.EMBEDDING_MODEL)
    vector_collection = chroma_client.get_collection(name="pubmed_papers") # Use get_collection, assumes it exists
    
    logging.info("Interactive Scout initialized successfully.")
except Exception:
    logging.critical("Failed to initialize clients or models for Interactive Scout.", exc_info=True)
    exit()

# --- SLACK COMMAND HANDLER ---
@app.command("/pubscout_ask")
def handle_ask_command(ack, body, say):
    """Handles the /pubscout_ask slash command."""
    # Acknowledge the command immediately to prevent Slack timeout errors
    ack()
    
    user_question = body['text']
    if not user_question:
        say("Please provide a question after the command. For example: `/pubscout_ask What is the link between quercetin and inflammation?`")
        return

    try:
        logging.info(f"Received question: '{user_question}'")
        say(f":mag: Searching my knowledge base for an answer to: \"_{user_question}_\"... Please wait.")

        # 1. Embed the user's question
        question_embedding = embedding_model.encode(user_question).tolist()

        # 2. Query the vector database for the top 5 most relevant papers
        logging.info("Querying vector DB for relevant context...")
        similar_results = vector_collection.query(
            query_embeddings=[question_embedding],
            n_results=5 # Retrieve more context for synthesis
        )

        # 3. Format the context for the LLM prompt
        context_for_prompt = "No relevant information found in the knowledge base."
        if similar_results and similar_results['documents'][0]:
            context_lines = []
            for doc, meta in zip(similar_results['documents'][0], similar_results['metadatas'][0]):
                # The 'doc' contains the full "Title: ... Abstract: ..." text
                context_lines.append(f"- From paper '{meta.get('title', 'N/A')}':\n{meta.get('summary', 'Summary not available.')}\n")
            context_for_prompt = "\n".join(context_lines)
            logging.info("Found relevant context for the RAG prompt.")
        else:
            logging.warning("No relevant context was found in the vector DB.")
            
        # 4. Create the prompt using the new template
        prompt = config.SYNTHESIS_PROMPT.format(
            context=context_for_prompt,
            question=user_question
        )

        # 5. Call the Groq LLM to synthesize an answer
        logging.info("Sending request to Groq API for synthesis...")
        chat_completion = groq_client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model=config.GROQ_MODEL # Use the same reliable model
        )
        answer = chat_completion.choices[0].message.content

        # 6. Send the final answer back to Slack
        say(
            channel=body['channel_id'],
            text=f"Here is the answer based on my knowledge base:",
            blocks=[
                {"type": "section", "text": {"type": "mrkdwn", "text": f"*Your Question:*\n> {user_question}"}},
                {"type": "divider"},
                {"type": "section", "text": {"type": "mrkdwn", "text": f"*Answer:*\n{answer}"}},
                {"type": "context", "elements": [{"type": "mrkdwn", "text": "Answer generated by PubScout. For informational purposes only."}]}
            ]
        )

    except Exception as e:
        logging.error(f"An error occurred while handling /pubscout_ask: {e}", exc_info=True)
        say(f"Sorry, an unexpected error occurred while processing your request. Please check the logs.")

# --- START THE BOT ---
if __name__ == "__main__":
    logging.info("Starting PubScout Interactive Bot...")
    # SocketModeHandler is great for development as it doesn't require a public IP/firewall changes
    handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    handler.start()